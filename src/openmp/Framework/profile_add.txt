diff --git a/src/serial/Framework/PluginFactory.cc b/src/serial/Framework/PluginFactory.cc
index 6e8a33e..9bdcda2 100644
--- a/src/serial/Framework/PluginFactory.cc
+++ b/src/serial/Framework/PluginFactory.cc
@@ -6,6 +6,7 @@ namespace edm {
   namespace PluginFactory {
     namespace impl {
       void Registry::add(std::string const& name, std::unique_ptr<MakerBase> maker) {
+        std::cout << "Adding plugin " << name << std::endl;
         auto found = pluginRegistry_.find(name);
         if (found != pluginRegistry_.end()) {
           throw std::logic_error("Plugin " + name + " is already registered");
@@ -28,7 +29,8 @@ namespace edm {
     };  // namespace impl
 
     std::unique_ptr<Worker> create(std::string const& name, ProductRegistry& reg) {
-      return impl::getGlobalRegistry().get(name)->create(reg);
+       std::cout << "create, name = " << name << std::endl;
+      return impl::getGlobalRegistry().get(name)->create(reg, name);
     }
   }  // namespace PluginFactory
 }  // namespace edm
diff --git a/src/serial/Framework/PluginFactory.h b/src/serial/Framework/PluginFactory.h
index dce323f..28dd83e 100644
--- a/src/serial/Framework/PluginFactory.h
+++ b/src/serial/Framework/PluginFactory.h
@@ -17,14 +17,14 @@ namespace edm {
       public:
         virtual ~MakerBase() = default;
 
-        virtual std::unique_ptr<Worker> create(ProductRegistry& reg) const = 0;
+        virtual std::unique_ptr<Worker> create(ProductRegistry& reg, const std::string &name) const = 0;
       };
 
       template <typename T>
       class Maker : public MakerBase {
       public:
-        virtual std::unique_ptr<Worker> create(ProductRegistry& reg) const override {
-          return std::make_unique<WorkerT<T>>(reg);
+        virtual std::unique_ptr<Worker> create(ProductRegistry& reg, const std::string &name) const override {
+          return std::make_unique<WorkerT<T>>(reg, name);
         };
       };
 
diff --git a/src/serial/Framework/Worker.h b/src/serial/Framework/Worker.h
index cd5631c..16f0c79 100644
--- a/src/serial/Framework/Worker.h
+++ b/src/serial/Framework/Worker.h
@@ -3,12 +3,14 @@
 
 #include <atomic>
 #include <vector>
-//#include <iostream>
+#include <iostream>
 
 #include "Framework/WaitingTask.h"
 #include "Framework/WaitingTaskHolder.h"
 #include "Framework/WaitingTaskList.h"
 #include "Framework/WaitingTaskWithArenaHolder.h"
+//#include "Framework/Timer.h"
+#include "Framework/Profile.h"
 
 namespace edm {
   class Event;
@@ -17,6 +19,7 @@ namespace edm {
 
   class Worker {
   public:
+    Worker(const std::string& name) : name_(name) /*, timer_(*timerManager.createTimer(name))*/ {}
     virtual ~Worker() = default;
 
     // not thread safe
@@ -39,6 +42,8 @@ namespace edm {
 
   protected:
     virtual void doReset() = 0;
+    std::string name_;
+    //Timer& timer_;
 
   private:
     std::vector<Worker*> itemsToGet_;
@@ -48,7 +53,7 @@ namespace edm {
   template <typename T>
   class WorkerT : public Worker {
   public:
-    explicit WorkerT(ProductRegistry& reg) : producer_(reg) {}
+    explicit WorkerT(ProductRegistry& reg, const std::string& name) : Worker(name), producer_(reg) {}
 
     void doWorkAsync(Event& event, EventSetup const& eventSetup, WaitingTaskHolder task) override {
       waitingTasksWork_.add(task);
@@ -64,8 +69,13 @@ namespace edm {
               } else {
                 std::exception_ptr exceptionPtr;
                 try {
-                  //std::cout << "calling doProduce " << this << std::endl;
+                  //std::cout << "calling doProduce " << this << " on " << name_ << std::endl;
+                  beginProduce(name_, event);
+                  //timer_.start();
                   producer_.doProduce(event, eventSetup);
+                  //timer_.stop();
+                  endProduce(name_, event);
+                  //std::cout << "done calling doProduce " << this << std::endl;
                 } catch (...) {
                   exceptionPtr = std::current_exception();
                 }
@@ -83,7 +93,13 @@ namespace edm {
             } else {
               std::exception_ptr exceptionPtr;
               try {
+                std::cout << "calling doAcquire " << this << " on " << name_ << std::endl;
+                beginAcquire(name_, event);
+                //timer_.start();
                 producer_.doAcquire(event, eventSetup, runProduceHolder);
+                //timer_.stop();
+                endAcquire(name_, event);
+                std::cout << "done calling doAcquire " << this << std::endl;
               } catch (...) {
                 exceptionPtr = std::current_exception();
               }
